#include <cstdio>
#include <cstdlib>

#include "linenoise.h"
#include <cxxopts.hpp>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <string>

#include "ast/optimizers/ConstantFolding.hpp"
#include "executable/Program.hpp"
#include "executable/bytecode/Bytecode.hpp"
#include "executable/bytecode/BytecodeProgram.hpp"
#include "executable/bytecode/codegen/BytecodeGenerator.hpp"
#include "executable/llvm/LLVMGenerator.hpp"
#include "interpreter/Interpreter.hpp"
#include "parser/Parser.hpp"
#include "runtime/modules/Modules.hpp"
#include "runtime/types/builtin.hpp"
#include "vm/VM.hpp"

using namespace py;

namespace repl {
std::optional<std::string> getline(const std::string &prompt)
{
	if (auto line = linenoise(prompt.c_str())) {
		linenoiseHistoryAdd(line);
		linenoiseHistorySave("history.txt");
		return std::string{ line };
	} else {
		return {};
	}
}


// FIXME
// class InteractivePython
// {
//   public:
// 	InteractivePython() {}

// 	PyObject *interpret_statement(std::string statement)
// 	{
// 		auto lexer = Lexer::create(statement, std::filesystem::current_path());
// 		parser::Parser parser{ lexer };
// 		parser.parse();
// 		if (!m_main_module) {
// 			m_main_module = parser.module();
// 		} else {
// 			for (const auto &node : parser.module()->body()) { m_main_module->emplace(node); }
// 		}
// 		auto bytecode =
// 			codegen::BytecodeGenerator::compile(m_main_module, compiler::OptimizationLevel::None);
// 		auto &vm = VirtualMachine::the();
// 		return vm.execute_statement(bytecode);
// 	}

//   private:
// 	std::shared_ptr<ast::Module> m_main_module{ nullptr };
// };

}// namespace repl

namespace {

void initialize_types()
{
	[[maybe_unused]] auto scope = VirtualMachine::the().heap().scoped_gc_pause();

	type();
	bool_();
	bytes();
	ellipsis();
	str();
	float_();
	integer();
	none();
	module();
	object();
	dict();
	dict_items();
	dict_items_iterator();
	list();
	list_iterator();
	tuple();
	tuple_iterator();
	range();
	range_iterator();
	function();
	native_function();
	code();
	cell();
	builtin_method();
	slot_wrapper();
	bound_method();
	method_wrapper();
	static_method();
	property();
	classmethod();
}


int run_and_execute_script(int argc,
	char **argv,
	bool print_bytecode,
	bool print_tokens,
	bool use_llvm,
	bool print_ast)
{
	size_t arg_idx{ 1 };
	const char *filename = argv[arg_idx];
	std::vector<std::string> argv_vector;
	argv_vector.reserve(argc - 1);
	while (arg_idx < argc) { argv_vector.emplace_back(argv[arg_idx++]); }

	auto &vm = VirtualMachine::the();
	auto lexer = Lexer::create(std::filesystem::absolute(filename));
	if (print_tokens) {
		auto l = Lexer::create(std::filesystem::absolute(filename));
		std::cout << "Generated tokens: \n";
		size_t idx = 0;
		while (auto token = l.peek_token(idx)) {
			std::cout << *token << '\n';
			idx++;
		}
		std::cout << std::endl;
	}
	parser::Parser p{ lexer };
	p.parse();
	if (print_ast) {
		const auto lvl = spdlog::get_level();
		spdlog::set_level(spdlog::level::debug);
		p.module()->print_node("");
		spdlog::set_level(lvl);
	}
	initialize_types();
	std::shared_ptr<Program> bytecode = codegen::BytecodeGenerator::compile(
		p.module(), argv_vector, compiler::OptimizationLevel::None);

	if (print_bytecode) {
		std::cout << "Generated bytecode: \n";
		std::cout << bytecode->to_string() << '\n';
	}
	if (use_llvm) {
#ifdef USE_LLVM
		auto llvm_code = codegen::LLVMGenerator::compile(
			p.module(), argv_vector, compiler::OptimizationLevel::None);
		if (!llvm_code) {
			std::cout << "Could not compile to LLVM IR\n";
		} else {
			std::cout << "------------------------------------------------\n";
			std::cout << "Generated LLVM IR (experimental feature): \n";
			std::cout << llvm_code->to_string() << '\n';
			std::cout << "------------------------------------------------\n";
			static_cast<BytecodeProgram *>(bytecode.get())->add_backend(llvm_code);
		}
#else
		std::cout << "Python interpreter was compiled without LLVM\n";
#endif
	}
	return vm.execute(bytecode);
}

int run_and_execute_module_as_script(int argc,
	char **argv,
	const std::string &module_name,
	bool print_bytecode,
	bool print_ast,
	bool print_tokens)
{
	size_t arg_idx{ 1 };
	std::vector<std::string> argv_vector;
	argv_vector.reserve(argc - 1);
	while (arg_idx < argc) { argv_vector.emplace_back(argv[arg_idx++]); }

	auto *sys = sys_module(VirtualMachine::the().interpreter());

	return 0;
}
}// namespace

int main(int argc, char **argv)
{
	cxxopts::Options options("python", "The C++ Python interpreter");

	// clang-format off
	options.add_options()
		("f,filename", "Script path", cxxopts::value<std::string>())
		("m", "run library module as a script", cxxopts::value<std::string>())
		("b,bytecode", "Print the script's bytecode to stdout", cxxopts::value<bool>()->default_value("false"))
		("a,ast", "Print the script's tokens to stdout", cxxopts::value<bool>()->default_value("false"))
		("t,tokenize", "Print the script's tokens to stdout", cxxopts::value<bool>()->default_value("false"))
		("d,debug", "Enable debug logging", cxxopts::value<bool>()->default_value("false"))
		("trace", "Enable trace logging", cxxopts::value<bool>()->default_value("false"))
		("use-llvm", "Enable trace logging", cxxopts::value<bool>()->default_value("false"))
		("h,help", "Print usage");
	options
		.positional_help("[optional args]")
		.show_positional_help();
	// clang-format on

	options.parse_positional({ "filename" });

	auto result = options.parse(argc, argv);

	if (result.count("help")) {
		std::cout << options.help() << std::endl;
		return EXIT_SUCCESS;
	}

	const bool debug = result["debug"].as<bool>();
	const bool trace = result["trace"].as<bool>();

	if (debug) { spdlog::set_level(spdlog::level::debug); }
	if (trace) { spdlog::set_level(spdlog::level::trace); }

	if (result.count("filename")) {
		return run_and_execute_script(argc,
			argv,
			result["bytecode"].as<bool>(),
			result["tokenize"].as<bool>(),
			result["use-llvm"].as<bool>(),
			result["ast"].as<bool>());
	}

	if (result.count("m")) {
		return run_and_execute_module_as_script(argc,
			argv,
			result["m"].as<std::string>(),
			result["bytecode"].as<bool>(),
			result["ast"].as<bool>(),
			result["tokenize"].as<bool>());
	}

	TODO();

	// FIXME
	// linenoiseHistoryLoad("history.txt");

	// repl::InteractivePython interactive_interpreter;

	// static constexpr std::string_view major_version = "3";
	// static constexpr std::string_view minor_version = "10";
	// static constexpr std::string_view build_version = "0a";
	// static constexpr std::string_view compiler = "Clang 11.0.0";
	// static constexpr std::string_view platform = "Linux";

	// std::cout << fmt::format("Python {}.{}.{}\n", major_version, minor_version, build_version);
	// std::cout << fmt::format("[{}] :: {}\n", compiler, platform);
	// std::cout << "Type \"help\", \"copyright\", \"credits\" or \"license\" for more
	// information."; std::cout << std::endl;

	// while (auto line = repl::getline(">>> ")) {
	// 	(*line) += "\n";
	// 	auto *result = interactive_interpreter.interpret_statement(*line);
	// 	if (result != py_none()) {
	// 		std::cout << result->repr_impl(VirtualMachine::the().interpreter())->to_string()
	// 				  << '\n';
	// 	}
	// }

	return EXIT_SUCCESS;
}