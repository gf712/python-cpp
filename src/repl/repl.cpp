#include <cstdio>
#include <cstdlib>

#include "linenoise.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <string>

#include "ast/optimizers/ConstantFolding.hpp"
#include "bytecode/BytecodeGenerator.hpp"
#include "interpreter/Interpreter.hpp"
#include "parser/Parser.hpp"
#include "vm/VM.hpp"

namespace repl {
std::optional<std::string> getline(const std::string &prompt)
{
	if (auto line = linenoise(prompt.c_str())) {
		linenoiseHistoryAdd(line);
		linenoiseHistorySave("history.txt");
		return std::string{ line };
	} else {
		return {};
	}
}


class InteractivePython
{
  public:
	InteractivePython() {}

	PyObject *interpret_statement(std::string statement)
	{
		Lexer lexer{ statement };
		parser::Parser parser{ lexer };
		parser.parse();
		if (!m_main_module) {
			m_main_module = parser.module();
		} else {
			for (const auto &node : parser.module()->body()) { m_main_module->emplace(node); }
		}
		auto bytecode =
			BytecodeGenerator::compile(m_main_module, compiler::OptimizationLevel::None);
		auto &vm = VirtualMachine::the();
		return vm.execute_statement(bytecode);
	}

  private:
	std::shared_ptr<ast::Module> m_main_module{ nullptr };
};

}// namespace repl

namespace {
int run_and_execute_script(const char *filename)
{
	std::filesystem::path path = filename;
	if (!std::filesystem::exists(path)) {
		std::cerr << fmt::format("File {} does not exist", path.c_str()) << std::endl;
		return EXIT_FAILURE;
	}

	std::ifstream in(std::filesystem::absolute(path).c_str());
	if (!in.is_open()) {
		std::cerr << fmt::format("Failed to open {}", std::filesystem::absolute(path).c_str())
				  << std::endl;
		return EXIT_FAILURE;
	}

	std::string program;

	in.seekg(0, std::ios::end);
	program.reserve(in.tellg());
	in.seekg(0, std::ios::beg);

	program.assign((std::istreambuf_iterator<char>(in)), std::istreambuf_iterator<char>());
	if (program.back() != '\n') { program.append("\n"); }

	spdlog::debug("Input program: \n----\n{}\n----\n", program.c_str());

	auto &vm = VirtualMachine::the();

	Lexer lexer{ program };
	parser::Parser p{ lexer };
	p.parse();
	auto bytecode = BytecodeGenerator::compile(p.module(), compiler::OptimizationLevel::None);
	vm.clear();
	spdlog::debug("Generated bytecode: \n{}", bytecode->to_string());
	vm.create(std::move(bytecode));
	vm.execute();

	return EXIT_SUCCESS;
}
}// namespace

int main(int argc, char **argv)
{
	if (argc > 1) {
		int parsed_args{ 1 };
		char *filename{ nullptr };
		do {
			if (strcmp(argv[parsed_args], "--debug") == 0) {
				spdlog::set_level(spdlog::level::debug);
			} else {
				filename = argv[parsed_args];
			}
		} while (++parsed_args < argc);
		if (filename) { return run_and_execute_script(filename); }
	}

	linenoiseHistoryLoad("history.txt");

	repl::InteractivePython interactive_interpreter;

	static constexpr std::string_view major_version = "3";
	static constexpr std::string_view minor_version = "10";
	static constexpr std::string_view build_version = "0a";
	static constexpr std::string_view compiler = "Clang 11.0.0";
	static constexpr std::string_view platform = "Linux";

	std::cout << fmt::format("Python {}.{}.{}\n", major_version, minor_version, build_version);
	std::cout << fmt::format("[{}] :: {}\n", compiler, platform);
	std::cout << "Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.";
	std::cout << std::endl;

	while (auto line = repl::getline(">>> ")) {
		(*line) += "\n";
		auto *result = interactive_interpreter.interpret_statement(*line);
		if (result != py_none()) {
			std::cout << result->repr_impl(*VirtualMachine::the().interpreter())->to_string()
					  << '\n';
		}
	}

	return EXIT_SUCCESS;
}