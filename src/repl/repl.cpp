#include <cstdio>
#include <cstdlib>

#include "linenoise.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <string>

#include "ast/optimizers/ConstantFolding.hpp"
#include "executable/Program.hpp"
#include "executable/bytecode/Bytecode.hpp"
#include "executable/bytecode/BytecodeGenerator.hpp"
#include "interpreter/Interpreter.hpp"
#include "parser/Parser.hpp"
#include "vm/VM.hpp"

namespace repl {
std::optional<std::string> getline(const std::string &prompt)
{
	if (auto line = linenoise(prompt.c_str())) {
		linenoiseHistoryAdd(line);
		linenoiseHistorySave("history.txt");
		return std::string{ line };
	} else {
		return {};
	}
}


// FIXME
// class InteractivePython
// {
//   public:
// 	InteractivePython() {}

// 	PyObject *interpret_statement(std::string statement)
// 	{
// 		auto lexer = Lexer::create(statement, std::filesystem::current_path());
// 		parser::Parser parser{ lexer };
// 		parser.parse();
// 		if (!m_main_module) {
// 			m_main_module = parser.module();
// 		} else {
// 			for (const auto &node : parser.module()->body()) { m_main_module->emplace(node); }
// 		}
// 		auto bytecode =
// 			BytecodeGenerator::compile(m_main_module, compiler::OptimizationLevel::None);
// 		auto &vm = VirtualMachine::the();
// 		return vm.execute_statement(bytecode);
// 	}

//   private:
// 	std::shared_ptr<ast::Module> m_main_module{ nullptr };
// };

}// namespace repl

namespace {
int run_and_execute_script(const char *filename)
{
	auto &vm = VirtualMachine::the();
	auto lexer = Lexer::create(std::filesystem::absolute(filename));
	// while (auto token = lexer.next_token()) {
	// 	spdlog::info(token.value().to_string());
	// }
	parser::Parser p{ lexer };
	p.parse();
	auto bytecode = BytecodeGenerator::compile(p.module(), compiler::OptimizationLevel::None);
	vm.clear();
	spdlog::debug("Generated bytecode: \n{}", bytecode->to_string());
	vm.execute(bytecode);

	return EXIT_SUCCESS;
}
}// namespace

int main(int argc, char **argv)
{
	if (argc > 1) {
		int parsed_args{ 1 };
		char *filename{ nullptr };
		do {
			if (strcmp(argv[parsed_args], "--debug") == 0) {
				spdlog::set_level(spdlog::level::debug);
			} else {
				filename = argv[parsed_args];
			}
		} while (++parsed_args < argc);
		if (filename) { return run_and_execute_script(filename); }
	}

	TODO()

	// FIXME
	// linenoiseHistoryLoad("history.txt");

	// repl::InteractivePython interactive_interpreter;

	// static constexpr std::string_view major_version = "3";
	// static constexpr std::string_view minor_version = "10";
	// static constexpr std::string_view build_version = "0a";
	// static constexpr std::string_view compiler = "Clang 11.0.0";
	// static constexpr std::string_view platform = "Linux";

	// std::cout << fmt::format("Python {}.{}.{}\n", major_version, minor_version, build_version);
	// std::cout << fmt::format("[{}] :: {}\n", compiler, platform);
	// std::cout << "Type \"help\", \"copyright\", \"credits\" or \"license\" for more
	// information."; std::cout << std::endl;

	// while (auto line = repl::getline(">>> ")) {
	// 	(*line) += "\n";
	// 	auto *result = interactive_interpreter.interpret_statement(*line);
	// 	if (result != py_none()) {
	// 		std::cout << result->repr_impl(VirtualMachine::the().interpreter())->to_string()
	// 				  << '\n';
	// 	}
	// }

	return EXIT_SUCCESS;
}