#include <cstdio>
#include <cstdlib>

#include "linenoise.h"
#include <cxxopts.hpp>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <optional>
#include <string>

#include "ast/optimizers/ConstantFolding.hpp"
#include "executable/Program.hpp"
#include "executable/bytecode/Bytecode.hpp"
#include "executable/bytecode/BytecodeProgram.hpp"
#include "executable/bytecode/codegen/BytecodeGenerator.hpp"
#include "executable/llvm/LLVMGenerator.hpp"
#include "interpreter/Interpreter.hpp"
#include "parser/Parser.hpp"
#include "vm/VM.hpp"

namespace repl {
std::optional<std::string> getline(const std::string &prompt)
{
	if (auto line = linenoise(prompt.c_str())) {
		linenoiseHistoryAdd(line);
		linenoiseHistorySave("history.txt");
		return std::string{ line };
	} else {
		return {};
	}
}


// FIXME
// class InteractivePython
// {
//   public:
// 	InteractivePython() {}

// 	PyObject *interpret_statement(std::string statement)
// 	{
// 		auto lexer = Lexer::create(statement, std::filesystem::current_path());
// 		parser::Parser parser{ lexer };
// 		parser.parse();
// 		if (!m_main_module) {
// 			m_main_module = parser.module();
// 		} else {
// 			for (const auto &node : parser.module()->body()) { m_main_module->emplace(node); }
// 		}
// 		auto bytecode =
// 			codegen::BytecodeGenerator::compile(m_main_module, compiler::OptimizationLevel::None);
// 		auto &vm = VirtualMachine::the();
// 		return vm.execute_statement(bytecode);
// 	}

//   private:
// 	std::shared_ptr<ast::Module> m_main_module{ nullptr };
// };

}// namespace repl

namespace {
int run_and_execute_script(int argc, char **argv, bool print_bytecode, bool print_tokens)
{
	size_t arg_idx{ 1 };
	const char *filename = argv[arg_idx];
	std::vector<std::string> argv_vector;
	argv_vector.reserve(argc - 1);
	while (arg_idx < argc) { argv_vector.emplace_back(argv[arg_idx++]); }

	auto &vm = VirtualMachine::the();
	auto lexer = Lexer::create(std::filesystem::absolute(filename));
	if (print_tokens) {
		auto l = Lexer::create(std::filesystem::absolute(filename));
		std::cout << "Generated tokens: \n";
		while (auto token = l.next_token()) { std::cout << *token << '\n'; }
		std::cout << std::endl;
	}
	parser::Parser p{ lexer };
	p.parse();
	auto bytecode = codegen::BytecodeGenerator::compile(
		p.module(), argv_vector, compiler::OptimizationLevel::None);

	if (print_bytecode) {
		std::cout << "Generated bytecode: \n";
		std::cout << bytecode->to_string() << '\n';
	}
	return vm.execute(bytecode);
}
}// namespace

int main(int argc, char **argv)
{
	cxxopts::Options options("python", "The C++ Python interpreter");

	// clang-format off
	options.add_options()
		("f,filename", "Script path", cxxopts::value<std::string>())
		("b,bytecode", "Print the script's bytecode to stdout", cxxopts::value<bool>()->default_value("false"))
		("t,tokenize", "Print the script's tokens to stdout", cxxopts::value<bool>()->default_value("false"))
		("d,debug", "Enable debug logging", cxxopts::value<bool>()->default_value("false"))
		("trace", "Enable trace logging", cxxopts::value<bool>()->default_value("false"))
		("h,help", "Print usage");
	options
		.positional_help("[optional args]")
		.show_positional_help();
	// clang-format on

	options.parse_positional({ "filename" });

	auto result = options.parse(argc, argv);

	if (result.count("help")) {
		std::cout << options.help() << std::endl;
		return EXIT_SUCCESS;
	}

	const bool debug = result["debug"].as<bool>();
	const bool trace = result["trace"].as<bool>();

	if (debug) { spdlog::set_level(spdlog::level::debug); }
	if (trace) { spdlog::set_level(spdlog::level::trace); }

	if (result.count("filename")) {
		return run_and_execute_script(
			argc, argv, result["bytecode"].as<bool>(), result["tokenize"].as<bool>());
	}

	TODO();

	// FIXME
	// linenoiseHistoryLoad("history.txt");

	// repl::InteractivePython interactive_interpreter;

	// static constexpr std::string_view major_version = "3";
	// static constexpr std::string_view minor_version = "10";
	// static constexpr std::string_view build_version = "0a";
	// static constexpr std::string_view compiler = "Clang 11.0.0";
	// static constexpr std::string_view platform = "Linux";

	// std::cout << fmt::format("Python {}.{}.{}\n", major_version, minor_version, build_version);
	// std::cout << fmt::format("[{}] :: {}\n", compiler, platform);
	// std::cout << "Type \"help\", \"copyright\", \"credits\" or \"license\" for more
	// information."; std::cout << std::endl;

	// while (auto line = repl::getline(">>> ")) {
	// 	(*line) += "\n";
	// 	auto *result = interactive_interpreter.interpret_statement(*line);
	// 	if (result != py_none()) {
	// 		std::cout << result->repr_impl(VirtualMachine::the().interpreter())->to_string()
	// 				  << '\n';
	// 	}
	// }

	return EXIT_SUCCESS;
}